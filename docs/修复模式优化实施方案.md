# 修复模式优化实施方案

## 需求概述
1. 添加当目标文件夹为空的时候，也不会触发修复模式的规则
2. 修复模式备份文件不通过程序删除，现有删除提示框改为，提示用户自行删除备份文件夹，用户确认后弹出源文件夹所在目录

## 实施计划

### 1. 修改修复模式触发条件

**文件**: `MoveWithSymlinkWPF/ViewModels/MainViewModel.cs`
**方法**: `CheckRepairCondition()`

**修改内容**: 在现有的检查条件后添加对目标文件夹是否为空的检查

```csharp
// 目标目录必须存在
if (!Directory.Exists(TargetPath))
    return;

// 新增：如果目标文件夹为空，不触发修复模式
bool targetIsEmpty = !PathValidator.HasUserContent(TargetPath);
if (targetIsEmpty)
    return;
```

### 2. 创建新的备份处理方法

**文件**: `MoveWithSymlinkWPF/ViewModels/MainViewModel.cs`
**新方法**: `CheckAndCleanupRepairBackupV2Async()`

**功能**:
- 保留原有的`CheckAndCleanupRepairBackupAsync()`方法不变
- 新方法实现以下逻辑：
  - 查找修复过程中创建的备份目录
  - 提示用户自行删除备份文件夹
  - 用户确认后弹出源文件夹所在目录

```csharp
/// <summary>
/// 检查并提示用户处理修复过程中产生的备份（新版本）
/// </summary>
private async Task CheckAndCleanupRepairBackupV2Async()
{
    await Task.Run(() =>
    {
        try
        {
            // 查找可能的备份目录
            string? parentDir = Path.GetDirectoryName(SourcePath);
            if (string.IsNullOrEmpty(parentDir) || !Directory.Exists(parentDir))
                return;

            string sourceName = Path.GetFileName(SourcePath);
            string backupPrefix = $"{sourceName}.bak_";

            var backups = Directory.GetDirectories(parentDir, $"{backupPrefix}*")
                .OrderByDescending(d => Directory.GetLastWriteTime(d))
                .ToList();

            if (backups.Any())
            {
                string backupPath = backups.First();
                
                Application.Current.Dispatcher.Invoke(() =>
                {
                    var askResult = MessageBox.Show(
                        $"修复过程中创建了备份目录：\n\n{backupPath}\n\n请自行删除此备份目录。\n\n是否打开备份所在目录？",
                        "备份处理提示",
                        MessageBoxButton.YesNo,
                        MessageBoxImage.Information);

                    if (askResult == MessageBoxResult.Yes)
                    {
                        try
                        {
                            AddLog($"打开备份所在目录: {Path.GetDirectoryName(backupPath)}");
                            
                            // 打开文件夹
                            ProcessStartInfo startInfo = new ProcessStartInfo
                            {
                                Arguments = Path.GetDirectoryName(backupPath),
                                FileName = "explorer.exe"
                            };
                            Process.Start(startInfo);
                        }
                        catch (Exception ex)
                        {
                            AddLog($"❌ 打开目录失败: {ex.Message}");
                            MessageBox.Show(
                                $"打开目录失败：{ex.Message}\n\n备份目录位置：{backupPath}", 
                                "操作失败", 
                                MessageBoxButton.OK, 
                                MessageBoxImage.Error);
                        }
                    }
                    else
                    {
                        AddLog($"备份已保留，请用户自行处理: {backupPath}");
                    }
                });
            }
        }
        catch (Exception ex)
        {
            AddLog($"检查备份时出错: {ex.Message}");
        }
    });
}
```

### 3. 修改修复完成后的调用

**文件**: `MoveWithSymlinkWPF/ViewModels/MainViewModel.cs`
**方法**: `StartRepairAsync()`

**修改内容**: 将修复完成后的调用从`CheckAndCleanupRepairBackupAsync()`改为`CheckAndCleanupRepairBackupV2Async()`

```csharp
// 修复完成后检查是否有备份需要处理
if (MigrationSuccess && MigrationCompleted)
{
    await CheckAndCleanupRepairBackupV2Async(); // 使用新的备份处理方法
}
```

## 测试计划

### 测试场景1：目标文件夹为空时不触发修复模式
1. 准备一个空的源目录和一个空的目标目录
2. 在UI中设置源路径和目标路径
3. 验证修复模式不会被触发

### 测试场景2：目标文件夹不为空时正常触发修复模式
1. 准备一个源目录（包含内容）和一个非空的目标目录
2. 在UI中设置源路径和目标路径
3. 验证修复模式正常触发

### 测试场景3：修复完成后的备份处理
1. 执行修复操作，创建备份
2. 验证新的备份处理提示出现
3. 点击"是"验证打开源文件夹所在目录
4. 点击"否"验证提示备份已保留

## 注意事项

1. 保留原有的`CheckAndCleanupRepairBackupAsync()`方法，以便需要时可以回退
2. 新方法的UI提示文本更加友好，明确提示用户自行删除
3. 使用`explorer.exe`打开文件夹是Windows系统标准做法
4. 添加适当的错误处理，防止打开文件夹时出现异常

## 实施时间安排

1. 修改CheckRepairCondition方法 - 30分钟
2. 创建新的备份处理方法 - 45分钟
3. 修改修复完成后的调用 - 15分钟
4. 测试各种场景 - 60分钟
5. 编写说明文档 - 30分钟

总计：约3小时